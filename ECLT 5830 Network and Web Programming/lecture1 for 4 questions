 
Week 1: Q1
æ•°å­—åè½¬
Let X be a variable that stores a positive integer in which its last digit
is not zero. Write a segment of JS code to reverse its digits.
e.g. if X = 13579; X should become 97531.


function reverseNumber(x) {
  let ans = 0
     while (x != 0) {
            ans = ans * 10 + (x % 10);
            x /= 10;
           //console.log(x);
           x = x - x % 1;//eliminate number after decimal point
           //console.log(x);
            };
       if (ans < Number.MIN_VALUE || ans > Number.MAX_VALUE) {
            ans = 0;
        }
        return ans;
}
var X = 13579;
console.log(Number(reverseNumber(X)));



Week 1: Q2
æ·±æ‹·è´åŠ æ’åº
Write a segment of JS code to make a DEEP copy of array "fruits" and sort the elements in
the cloned array by "id" in ascending order.
const fruits = [
  {id:43, title:'Apple', price:12}, {id:21, title:'Banana', price:5},
  {id:13, title:'Orange', price:8}, {id:55, title:'Mango', price:15},
  {id:44, title:'Grape', price:10}, {id:6, title:'Peach', price: 14}
]


const fruits = [
  {id:43, title:'Apple', price:12}, {id:21, title:'Banana', price:5},
  {id:13, title:'Orange', price:8}, {id:55, title:'Mango', price:15},
  {id:44, title:'Grape', price:10}, {id:6, title:'Peach', price: 14}
]
//console.log(fruits);

function deepCopy(obj){
  var result = Array.isArray(obj)?[]:{};
  for(var key in obj){
    if(obj.hasOwnProperty(key)){
      if(typeof obj[key]==="object"){
        result[key] = deepCopy(obj[key]); //é€’å½’å¤åˆ¶
      }else{
        result[key] = obj[key];
      }
    }
  }
return result;
}

console.log(deepCopy(fruits));
const newfruits =deepCopy(fruits);
newfruits.sort(function(a,b){return a.id - b.id});
console.log(newfruits);

/*
Shallow copy copies only the first layer of an object, Deep objects(å¯¹è±¡å†…è¿˜æœ‰å¯¹è±¡) copy their references
Deep copy copies every layer of data
We need to figure out what we need is to copy only the first level of object or array elements, or
recursively copy all levels of objects and array elements
*/

å…³äºæ·±æ‹·è´ï¼š

The recursive approach shown here or the JSON approach used by many students in this question would not work on objects or arrays with circular reference.
To combat circular reference, one would need customized code to keep track of all the references in the source object so that same references in the source object would map to same references in the target object.

å…³äºä»€ä¹ˆæ˜¯å¾ªç¯å¼•ç”¨ï¼Ÿè¿™é‡Œæˆ‘ä¸€å¼€å§‹å‡ºç°äº†ç†è§£çš„é”™è¯¯
è¿™æ˜¯åŒç­ä¸€ä½åŒå­¦æ€»ç»“çš„
 Imagine object as human,
we can use our fingers to point to other people
if A's finger point to B, and B's finger point to A, that is circular reference
but if I use my finger pointing to myself, that is also circular reference.



Week 1: Q3
è®¡ç®—æ•°å€¼é•¿åº¦ï¼ˆjsä¸­æ•°çš„æœ‰æ•ˆæ€§ï¼‰
Implement a function named "length" that takes one parameter and perform the
followings:
- If the parameter is an array, return its length (# of elements)
- If the parameter is a string, return its length (# of characters)
- If the parameter is a number that is neither NaN nor Infinity, return the
number of digits in its integer portion. (e.g., for -456.99, the integer
portion is -456, so return 3)
- Otherwise, return 0
Note: For simplicity, your solution does not need to deal with floating point numbers, when converted to string, appear in scientific notation such as 3E-50 or 3E50.


function length(x) {
 if(Array.isArray(x) || typeof(x)=="string")
  return x.length;
 
 if(typeof(x)=="number" && !isNaN(x) && isFinite(x) && Number.MIN_SAFE_INTEGER <= x && x <= Number.MAX_SAFE_INTEGER ){
    //var tmp = x.toString();
      // console.log(tmp);
    //console.log(x);
    return Math.abs(parseInt(x)).toString().length;
  }
if(typeof(x)=="number" && !isNaN(x) && isFinite(x) )
{
 if(x < Number.MIN_SAFE_INTEGER || x > Number.MAX_SAFE_INTEGER)
 {
  
  var tmp = x.toString();
    console.log(tmp);
    //console.log(tmp.indexOf('e'));
    //console.log(tmp.indexOf('+'));
    if(tmp.indexOf('e') == 1 && tmp.substr(0, 1) == '1')
    {
     var a = parseInt(tmp.slice((tmp.indexOf('+')+1)));
        return a;
 }
    var b = parseInt(tmp.slice((tmp.indexOf('+')+1))) + 1;
    return b;
 }
}
 
 return 0;
}

console.log(length(9999999999999999999999999));
console.log(length(9999999999999999999999999.897979797));
console.log(length(-9999999.9));
console.log(length(9999.9))
console.log(length(45213213121111111119900000000));
console.log(length(-45213213121111111119900000000.999))
console.log(length(NaN));
console.log(length(Infinity));
console.log(length(true));
//console.log(Number.MIN_SAFE_INTEGER);
//console.log(Number.MAX_SAFE_INTEGER);



hello. actually in JS we will be limited by Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER. I don't find some answer about how to return big numbers' length.
for example how to show the length of "9999999999999999999999999" and even "45213213121111111119900000000"
and "9999999999999999999999999.897979797" and "-45213213121111111119900000000.999"
I try to use some methods to solve it ,although it is a very stupid way ğŸ˜‚.


Also, why do you perform this specific checking?
if(tmp.indexOf('e') == 1 && tmp.substr(0, 1) == '1')
å› ä¸º99999999999999999è¿™ç±»çš„æ•°æ‰ä¼šè¿›ä½ï¼Œè¿›ä½åˆ™è®¡ç®—é•¿åº¦çš„æ—¶å€™å°±ä¼šå¢åŠ ä¸€ä½ï¼Œé•¿åº¦å°±ä¼šå˜é•¿ä¸€ä½ã€‚
ä½†æ˜¯å¦‚æœæœ¬æ¥å°±æ˜¯1000203233030232000009829929ï¼Œ è¿™æ ·ç§‘å­¦è®¡æ•°æ³•å¾—å‡º1.000203233030232e+27ï¼Œè¿™ç§å°±æ˜¯æ­£å¸¸æƒ…å†µä¸ä¼šå¢åŠ ä¸€ä½ã€‚
åªæœ‰â€œ1 â€œå’Œ â€e â€œ æ˜¯ç´§æŒ¨åœ¨ä¸€èµ·çš„æ‰ä¼šæ˜¯è¿›ä½çš„æƒ…å†µ

ä»¥ä¸Šå‡ºç°äº†ä¸€ä¸ªé”™è¯¯çš„é—®é¢˜ï¼Œé¦–å…ˆæ˜¯è¿™é‡Œæˆ‘åªè€ƒè™‘äº†è¿›ä½çš„æƒ…å†µå¦‚ä¸Šè¿°ï¼Œå¦‚æœæ˜¯21ä¸ª9çš„æ•°å­—ä¼šå˜æˆ1e+21å°±å˜æˆäº†é•¿åº¦ä¸º22çš„æ•°å­—ï¼Œä½†æ˜¯å¦‚æœæœ¬æ¥å°±æ˜¯ä¸ºäº†æµ‹é‡1e+21çš„é•¿åº¦çš„è¯ï¼Œç¨‹åºä¼šè¾“å‡ºå…¶é•¿åº¦ä¸º21ï¼Œè¿™æ ·å°±å‡ºç°äº†é”™è¯¯ã€‚

è€å¸ˆåœ¨æŒ‡å‡ºæˆ‘çš„é—®é¢˜æ˜¯å°†21ä¸ª9 ç§°ä½œ stringï¼Œæˆ‘å°±äº§ç”Ÿäº†ç–‘é—®ï¼Œè¿™ä¸æ˜¯æ•°å­—å—ï¼Œä¸ºä»€ä¹ˆæ˜¯stringã€‚

æ•°å­—åœ¨ Js interpreter ä¸­æ˜¯è¢«çœ‹ä½œä¸€ä¸²å­—ç¬¦ä¸²ç„¶åå°†è¿™ä¸ªå­—ç¬¦ä¸²è½¬åŒ–ä¸ºæœ€ç›¸è¿‘çš„æ•°å­—
è€å¸ˆçš„å›ç­”ï¼š
When we type a number literal in the JS source code, the JS interpreter read the literal as a string character by character, and then convert the string to the nearest number that can be represented in IEEE754 format (in binary).
for example
let a = 1.00000000000000000000000000000000001;
console.log(a == 1); // true
When the JS interpreter reads the code, it reads 1.00000000000000000000000000000000001 as a string and then converts the string to the nearest represetable number in IEEE754 format, which is 1 in this case. That's why the exact value of variable a is 1
Similarly, because 999999999999999999999 cannot be represented exactly in IEEE754 format, it is rounded to the nearest representable value, which is 1e+21.

let b = 999999999999999999999;      // We can type this number in the source code, but the actual value assigned to the variable is 1e+21.
console.log(b);          // 1e+21
console.log(b == 1e+21); // true
To the JS interpreter, everything we type in the source code, including number literals, are just strings.
That's why I called 999999999999999999999 a string (and not an actual number); the actual value represented by such a string is rounded to 1e+21.



Week 1: Q4
Implement a function that takes one parameter and returns true if the parameter
is an object containing the following three properties:
'foo', 'bar', and 'foo-bar'. Otherwise, the function returns false.
Please note that the value of the properties can be undefined.


function checkKey(obj){
    if(obj==undefined){
        return false;
    }
    return (("foo" in obj) &&("bar" in obj)&&("foo-bar" in obj));
    //return obj.hasOwnProperty('foo') && obj.hasOwnProperty('bar') && obj.hasOwnProperty('foo-bar');
}

let A = { foo: 1, bar: 2 };
console.log(A);
A.__proto__['foo-bar'] = 12345;
console.log(A);
console.log(A['foo-bar']);// 12345 (A has access to inherited property)
console.log(checkKey(A));

è¿™é‡Œä¸»è¦æ˜¯è¦å¼„æ‡‚ è‡ªèº«å±æ€§å’Œç»§æ‰¿å±æ€§  __proto__  prototype  constructor ä¸‰ç§åŒºåˆ«ä¸è”ç³»


